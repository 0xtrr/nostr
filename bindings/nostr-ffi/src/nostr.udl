// Copyright (c) 2022-2023 Yuki Kishimoto
// Distributed under the MIT software license

namespace nostr {
    [Throws=NostrError]
    string nip04_encrypt(SecretKey secret_key, PublicKey public_key, string content);
    [Throws=NostrError]
    string nip04_decrypt(SecretKey secret_key, PublicKey public_key, string encrypted_content);
};

[Error]
interface NostrError {
    Generic(string err);
};

interface Timestamp {
    [Name=now]
    constructor();
    [Name=from_secs]
    constructor(u64 secs);
    u64 as_secs();
    string to_human_datetime();
};

interface SecretKey {
    [Throws=NostrError, Name=from_hex]
    constructor(string hex);
    [Throws=NostrError, Name=from_bech32]
    constructor(string pk);
    string to_hex();
    [Throws=NostrError]
    string to_bech32();
};

interface PublicKey {
    [Throws=NostrError, Name=from_hex]
    constructor(string hex);
    [Throws=NostrError, Name=from_bech32]
    constructor(string pk);
    string to_hex();
    [Throws=NostrError]
    string to_bech32();
};

interface Keys {
    constructor(SecretKey sk);
    [Name=from_public_key]
    constructor(PublicKey pk);
    [Throws=NostrError, Name=from_sk_str]
    constructor(string sk);
    [Throws=NostrError, Name=from_pk_str]
    constructor(string pk);
    [Name=generate]
    constructor();
    [Throws=NostrError, Name=from_mnemonic]
    constructor(string mnemonic, optional string? passphrase = null);
    PublicKey public_key();
    [Throws=NostrError]
    SecretKey secret_key();
};

[Enum]
interface ClientMessage {
  Ev(string event);
  Req(string subscription_id, sequence<string> filters);
  Count(string subscription_id, sequence<string> filters);
  Close(string subscription_id);
  Auth(string event);
};

[Enum]
interface RelayMessage {
  Ev(string subscription_id, string event);
  Notice(string message);
  EndOfStoredEvents(string subscription_id);
  Ok(string event_id, boolean status, string message);
  Auth(string challenge);
  Count(string subscription_id, u64 count);
};

interface Filter {
    constructor();
    [Throws=NostrError, Self=ByArc]
    Filter id(string id);
    [Throws=NostrError, Self=ByArc]
    Filter ids(sequence<string> ids);
    [Self=ByArc]
    Filter kind(u64 kind);
    [Throws=NostrError, Self=ByArc]
    Filter event(string event_id);
    [Self=ByArc]
    Filter pubkey(PublicKey pubkey);
    [Self=ByArc]
    Filter since(u64 timestamp);
    [Self=ByArc]
    Filter until(u64 timestamp);
    [Throws=NostrError, Self=ByArc]
    Filter authors(sequence<string> authors);
};

interface EventId {
    [Throws=NostrError]
    constructor(PublicKey pubkey, Timestamp created_at, u64 kind, sequence<sequence<string>> tags, string content);
    [Throws=NostrError, Name=from_slice]
    constructor(sequence<u8> bytes);
    [Throws=NostrError, Name=from_hex]
    constructor(string hex);
    [Throws=NostrError, Name=from_bech32]
    constructor(string id);
    sequence<u8> as_bytes();
    string to_hex();
    [Throws=NostrError]
    string to_bech32();
};

interface UnsignedEvent {
    EventId id();
    PublicKey pubkey();
    Timestamp created_at();
    u64 kind();
    string content();
    [Throws=NostrError]
    Event sign(Keys keys);
    [Throws=NostrError]
    Event add_signature(string sig);
    [Throws=NostrError, Name=from_json]
    constructor(string json);
    string as_json();
};

interface Event {
    EventId id();
    PublicKey pubkey();
    Timestamp created_at();
    u64 kind();
    string content();
    string signature();
    boolean verify();
    [Throws=NostrError, Name=from_json]
    constructor(string json);
    string as_json();
};

interface EventBuilder {
    [Throws=NostrError]
    constructor(u64 kind, string content, sequence<sequence<string>> tags);
    [Throws=NostrError]
    Event to_event(Keys keys);
    [Throws=NostrError]
    Event to_pow_event(Keys keys, u8 difficulty);
    UnsignedEvent to_unsigned_event(PublicKey public_key);
    UnsignedEvent to_unsigned_pow_event(PublicKey public_key, u8 difficulty);

    [Name=set_metadata]
    constructor(AccountMetadata metadata);
    [Throws=NostrError, Name=add_recommended_relay]
    constructor(string url);
    [Throws=NostrError, Name=new_text_note]
    constructor(string content, sequence<sequence<string>> tags);
    [Throws=NostrError, Name=long_form_text_note]
    constructor(string content, sequence<sequence<string>> tags);
    [Name=repost]
    constructor(EventId event_id, PublicKey public_key);
    [Name=set_contact_list]
    constructor(sequence<Contact> list);
    [Throws=NostrError, Name=new_encrypted_direct_msg]
    constructor(Keys sender_keys, PublicKey receiver_pubkey, string content);
    [Name=delete]
    constructor(sequence<EventId> ids, optional string? reason = null);
    [Name=new_reaction]
    constructor(EventId event_id, PublicKey public_key, string content);

    [Name=new_channel]
    constructor(AccountMetadata metadata);
    [Throws=NostrError, Name=set_channel_metadata]
    constructor(string channel_id, string? relay_url, AccountMetadata metadata);
    [Throws=NostrError, Name=new_channel_msg]
    constructor(string channel_id, string relay_url, string content);
    [Name=hide_channel_msg]
    constructor(EventId message_id, string? reason);
    [Name=mute_channel_user]
    constructor(PublicKey public_key, string? reason);

    [Throws=NostrError, Name=auth]
    constructor(string challenge, string relay_url);
};

interface Contact {
    constructor(PublicKey pk, optional string? relay_url = null, optional string? alias = null);
    string? alias();
    PublicKey public_key();
    string? relay_url();
};

interface AccountMetadata {
    constructor();
    [Self=ByArc]
    AccountMetadata name(string name);
    [Self=ByArc]
    AccountMetadata display_name(string display_name);
    [Self=ByArc]
    AccountMetadata about(string about);
    [Throws=NostrError, Self=ByArc]
    AccountMetadata picture(string picture);
    [Self=ByArc]
    AccountMetadata nip05(string nip05);
};